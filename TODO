=========Core functionality==========
----------STAGE 1
x Flesh out lexer - actually spit out tokens that aren't just strings
x Refactor tokenizing special chars (implement/use a map? just an assoc list)
x Flesh out ast structure. Is a program just a list of function definitions?
    - Did this a bit. Need to clarify how I want to handle typing, variable declarations
- Figure out how to parse function definitions, particularly the parameters and how functions should
    be stored.
    x Implement expect function where I can expect a token and error out if it's bad
    - Add a comma token which I feel like is needed for parameter parsing
    x Ability to introspect on an AST. Print outs?
        - This sort of works
    - make code not a giant mess
x Read program from string into file
- Remove unnecessary pointers from typedefs
x Generate Assembly for first pass
x add list_concat(list_t *l1, list_t *l2) function that will append l2 to the end of l1
- UNIT TESTING!!! for containers (list, string) and tokenizing/parsing code.
    - I'd like to be able to spit out useful errors as well bc that would be easier to debug
    - I am very paranoid about seg faulting and I'm sure there are a ton of bugs here
x Refactor, especially very hacked together asm generation code. 
    - also python script which calls gcc. find path to compiler in better way

---------STAGE 2
wow 2ez done

---------STAGE 3
x Figure out a good AST structure including binary operations.
x Figure out parsing strategy for binary operations - I don't like the whole factor/term thing, even
    though that probably works. Sounds like it would be confusing when I try to add assignment or other
    binops. Maybe I can define a precedence level somehow that would inform the parsing strategy.
    x Bake the precedence into the parsing strategy!

---------STAGE 4
- I wonder if I can generalize all the parsing code...
- Refactor asm generation code. Simplify construction of instructions.

==========Nice to have==========
- Less questionable organization of code
- Decent error messages
- Properly reclaim used memory


==========Notes==========
What's an expression in C? I'm thinking it's one of:
    - A literal
    - A function call
    - An identifier/variable
    - A unary expression (e.g., x++, --x, *x, x->y, x.y, etc.), which is composed of an expression
    and a unary op
        - (3+2)++ is NOT a valid C expression - compiler says that for pre/postfix inc/dec the
        expression must be an lval
        - however, *(int*)(3+2) is valid, so maybe pointer deref and pre/postfix inc/dec are
        fundamentally different?
    - A binary operation (+, -, /, *, <<, etc), which is composed of an expression, an operator, and
    another expression

How the fuck are pointers implemented? I guess at some point I'll want to do an IR, probably similar
to the one in the Racket book I did at RC which was just x86 assembly but with variable names/types.
