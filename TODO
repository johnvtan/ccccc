=========Core functionality==========
----------STAGE 1
x Flesh out lexer - actually spit out tokens that aren't just strings
x Refactor tokenizing special chars (implement/use a map? just an assoc list)
x Flesh out ast structure. Is a program just a list of function definitions?
    - Did this a bit. Need to clarify how I want to handle typing, variable declarations
- Figure out how to parse function definitions, particularly the parameters and how functions should
    be stored.
    x Implement expect function where I can expect a token and error out if it's bad
    - Add a comma token which I feel like is needed for parameter parsing
    x Ability to introspect on an AST. Print outs?
        - This sort of works
    - make code not a giant mess
x Read program from string into file
- Remove unnecessary pointers from typedefs
x Generate Assembly for first pass
x add list_concat(list_t *l1, list_t *l2) function that will append l2 to the end of l1
- UNIT TESTING!!! for containers (list, string) and tokenizing/parsing code.
    - I'd like to be able to spit out useful errors as well bc that would be easier to debug
    - I am very paranoid about seg faulting and I'm sure there are a ton of bugs here
x Refactor, especially very hacked together asm generation code. 
    - also python script which calls gcc. find path to compiler in better way

---------STAGE 2
wow 2ez done

---------STAGE 3
x Figure out a good AST structure including binary operations.
x Figure out parsing strategy for binary operations - I don't like the whole factor/term thing, even
    though that probably works. Sounds like it would be confusing when I try to add assignment or other
    binops. Maybe I can define a precedence level somehow that would inform the parsing strategy.
    x Bake the precedence into the parsing strategy!

---------STAGE 4
x I wonder if I can generalize all the parsing code...
x Refactor asm generation code. Simplify construction of instructions.
- add the other bin ops.
- Can I simplify my bin op generation code? its in one giant function and it works but...

---------STAGE 5
x implement a map, just container on top of a list
- Think about assignment parsing more, there has to be a way to integrate it with current parsing
sttrategy and make it a binary op.
    - I have to figure out the precedence level of an assignment. I'd like to think that it's at the
    top, but I'm not sure. It's also right associative.
    - How do I parse the LHS? How do I know if I'm actually in an assignment stmt?
    - Or maybe just make it a separate expression and cave in
- Will probably want to introduce the IR from essentials of compilation here since I now have
variables that can conflict with each other.
 - Split code generation pass: one that generates IR (x86 with variables), one that takes that IR
 and allocates space for each variable and returns a map, and one (or two?) more that takes the map
 and the IR instruction list and outputs valid x86 complete with patched instructions. I'm like
 starting to worry about how much memory compiling a large file will take.
    - Like in EoC, the register allocation step can happen in the pass that takes the IR and
    produces a map. For now, it will only output offsets from EBP, but later it can also do
    registers and do the whole interference graph stuff.
- i really need to write unit tests lol, like for map and list and when I probably have a graph data
structure

==========Nice to have==========
- Less questionable organization of code
- Decent error messages
- Properly reclaim used memory


==========Notes==========
What's an expression in C? I'm thinking it's one of:
    - A literal
    - A function call
    - An identifier/variable
    - A unary expression (e.g., x++, --x, *x, x->y, x.y, etc.), which is composed of an expression
    and a unary op
        - (3+2)++ is NOT a valid C expression - compiler says that for pre/postfix inc/dec the
        expression must be an lval
        - however, *(int*)(3+2) is valid, so maybe pointer deref and pre/postfix inc/dec are
        fundamentally different?
    - A binary operation (+, -, /, *, <<, etc), which is composed of an expression, an operator, and
    another expression

How the fuck are pointers implemented? I guess at some point I'll want to do an IR, probably similar
to the one in the Racket book I did at RC which was just x86 assembly but with variable names/types.
